# G.A.I.A.

## Overview
G.A.I.A. (Generative Audio via Interaction with Ambient) is an ambient synth that takes its data both from the environment and from the user interaction.
G.A.I.A. generates ambient sound which varies with respect to ambient parameters' changes and user interaction, and generates also a visual associated with these changes.

---

## Project Structure

- Arduino: collects real world data (temperature, humidity and lightness) throught sensors;
- SuperCollider: audio synthesys;
- JUCE: plug-ins development;
- Reaper: DAW where JUCE plug-in created can run and modify sounds generated by SuperCollider. To route audio from SuperCollider to Repaer, ReaRoute driver has been used.
- Processing: visual synthesys;
- OSC: protocol that allows to send messages containing data from Arduino to SuperCollider and Processing.
- G.A.I.A. Custom Case: 3D printed custom case which allows better interaction with sensors.

---

## Modules and Files

1. **GAIA_Arduino**: reads real-time environmental data from a DHT22 sensor (temperature and humidity) and a photoresistor (light). The collected values are transmitted over a local network using the OSC (Open Sound Control) protocol to two different applications: SuperCollider and Processing —each on a separate UDP port. Additionally, the program generates random time-based events (bars and musical notes), which are sent to SuperCollider to influence sound generation. This creates an interactive audiovisual system that responds dynamically to environmental conditions. 

2. **GAIA_Supercollider**: creates a generative audio system that reacts to real-time environmental data received via OSC from an Arduino board or simulated inputs. The system responds to temperature, humidity and light levels, as well as rhythmic triggers, to control the GAIA synth.
The script includes multiple sections:
- Setup and Controls – Initializes the SuperCollider server and configures audio and OSC settings.
- OSC Reception – Defines how incoming sensor data and triggers are received and mapped to synthesis parameters.
- Print Routine – Continuously prints formatted sensor and control values for debugging and monitoring.
- Synth Definition – The GAIA SynthDef generates harmonically rich textures using bass lines, chords, and melodic notes. Each       element is modulated by incoming sensor values, enabling dynamic, environment-driven soundscapes.

Execution Modes:
- Arduino Mode: Receives real sensor data and triggers from an Arduino via OSC.
- Simulator Mode: Generates random sensor values and triggers for testing without hardware, and sends them to Processing and JUCE over OSC.

Focus on the GAIA Synth:
The GAIA synth is designed as a dynamic, ambient sound generator that reacts expressively to environmental input. It blends three key sound layers — bass, chords, and melodic notes — each modulated by sensor data received via OSC.
Structure and Features:
- Bass Layer:
     Based on a step-sequenced selection of MIDI notes, the bass is built from two detuned LFPar oscillators. The modulation depth is influenced by light intensity, creating evolving low-frequency movement.

- Chord Layer:
    A selection of 3-note chords is triggered by a bar-level pulse. The harmonic content (number of partials) is controlled by light, while humidity influences the chord envelope's duration. Chords are synthesized using Blip oscillators, contributing a shimmering, rich harmonic layer.

- Melodic Layer:
    Short notes are generated using SinOsc and triggered independently of the chord progression. The note value, duration, and trigger are all received via OSC, allowing fine-grained control—ideal for melodic interaction.

- Modulations:
    Temperature adjusts the LFO speed for amplitude modulation and sets the tonal center — essentially the root note around which harmonies are constructed.
    Humidity modulates envelope durations, affecting the sustain of the chords.
    Light modulates both the number of harmonics and the detuning of bass oscillators, enriching the timbral complexity.

- Output:
    The final signal is sent in 6 separate channels (3 couple of R/L signals) to Reaper for further processing.

3. **GAIA_Juce**
 JUCE-based audio plugin that processes stereo audio using three common effects: distortion, delay, and reverb. The architecture is modular and cleanly separated into three main components: the processor (PluginProcessor.cpp), the logic and user interface setup for the effects themselves (PluginEffects.cpp), and the visual editor (PluginEditor.cpp).

 - Plugin Processor:
 Is the heart of the audio processing logic. It defines the GAIAJuceAudioProcessor class, which inherits from JUCE’s AudioProcessor and the custom class GAIAJuceEffects, defined in the files PluginEffects.cpp and PluginEffects.h. It initializes and manages a circular buffer (dbuf) used to implement the delay effect, and maintains read and write indices for this buffer. Within the prepareToPlay function, it resizes the delay buffer to the maximum expected delay length and resets internal counters. The processBlock method is responsible for processing each incoming block of audio samples. It begins by clearing the output buffer and retrieving the delay buffer size from the GUI. Then, for each audio sample, it reads input from both left and right channels, applies distortion and delay effects in sequence, and finally processes the entire buffer with reverb. After applying all three effects, it writes the resulting samples back to the output buffer. The use of floating-point processing, combined with JUCE’s built-in utilities (like jlimit), ensures performance and safety during signal transformation.
 
 - Plugin Effects:
 This file is responsible for both the implementation of the effects themselves and their corresponding GUI controls. The code organizes the effects into reusable blocks through the EffectUIBlock structure, which contains an array of sliders and labels. The function setupMixerUI is called from the editor and takes care of adding all effect components to the GUI using a callback. For each effect, the function setUpArea is used to configure its sliders and labels dynamically depending on the number of parameters it requires. Spacing and layout are computed programmatically to ensure consistency. Each slider is a rotary knob with a text box underneath, and their ranges and initial values are set differently depending on the effect.
 The effects themselves are straightforward but functional. The distortion effect applies a simple waveshaping algorithm by multiplying the input sample by a drive factor and clamping it to a narrow range, then blending it with the dry signal. The delay effect takes a single delayed sample from the circular buffer and mixes it with the dry input. The reverb is implemented using JUCE’s built-in Reverb class, with parameters such as room size, damping, width, and freeze mode mapped directly from the sliders.

 - Plugin Editor:
 This file defines the plugin’s graphical user interface. The editor class, GAIAJuceAudioProcessorEditor, inherits from JUCE’s AudioProcessorEditor. During construction, it invokes the setupMixerUI function from the processor, which effectively delegates the responsibility of setting up all effect-related sliders and labels. This approach reinforces modularity and ensures that the logic for arranging components stays with the effects system. In the paint method, the editor draws a solid background and horizontal lines to visually separate each effect section.

4. **GAIA_Reaper**:
This file represents a complete DAW session built around the JUCE-based plugins. The project contains three tracks, each hosting a unique instance of the GAIA_Juce.vst3 plugin. These instances are active (not bypassed), stereo-configured, and set up for recording. Each plugin window has a defined floating position, indicating a user-prepared workspace layout for visual clarity and control.
All three tracks are nearly identical in configuration, designed to evaluate or perform with multiple parallel plugin instances.

5. **GAIA_Processing**
This Processing sketch creates a dynamic particle system that reacts in real-time to environmental sensor data received via OSC messages from Arduino. The data includes temperature, humidity, and light levels, which are mapped to control the color, lifespan, and acceleration of particles on screen. By continuously receiving and normalizing the sensor values, the sketch adjusts the particle behavior and appearance, producing an evolving and interactive visual representation of the surrounding environment.

- GAIA_processing.pde:
This part of the code sets up the OSC receiver to listen for messages on a specific UDP port. It translates the raw integer sensor values into normalized floats between zero and one, suitable for controlling visual parameters. This segment also initializes the particle system with a set number of particles and continuously updates the system each frame based on the latest sensor readings. Additionally, it includes debug prints to track incoming OSC messages and the mapped values, helping verify that data flows correctly from the sensors into the visual system.

- particle.pde:
This part defines the Particle class, representing individual particles within the system. Each particle has properties like position, velocity, acceleration, radius, lifespan, and a hue value that determines its color. Particles respond to forces by adjusting their acceleration and velocity, allowing for natural movement behaviors. As time progresses, their lifespan gradually decreases until they “die” and get removed from the system. This class also handles rendering each particle with colors based on the hue, which is linked to the light sensor value, adding a direct visual correlation between environmental data and particle appearance.

- particleSys.pde:
This section implements the ParticleSystem class, which manages a collection of Particle instances. This class controls how new particles are born, how they move, and how they are removed when expired. The birth rate is linked to humidity levels, meaning wetter conditions produce more particles. The acceleration forces applied to particles are scaled by temperature levels, influencing their speed and movement dynamics. The particle colors are also adjusted according to lightness. The system ensures a maximum number of particles to maintain performance and applies small random forces each frame to create organic, lively motion. The combination of these controls provides a rich and nuanced visual environment that mirrors the sensor inputs in an engaging and artistic way.

6. **GAIA_3DPrint**: 
This OpenSCAD script defines a custom 3D-printable enclosure for the G.A.I.A. circuit system. The design includes a main rectangular box with tilted cylindrical ports for the two sensors — photoresistor (LDR) and DHT temperature/humidity sensor. The enclosure is hollowed to accommodate a MKR board, and offers a detachable top cover and sensor mounting geometries for precise fitting. The layout is modular, cleanly separating the main body, sensor ports, internal cavity, and optional attachments (e.g., LDR port and box cover).

---

## Technologies Used
- **Interaction System**: Arduino MKR WiFi 1010, DHT22 temperature and humidity sensor, LDR photoresistor, OSC protocol;
- **Audio Syntesys**: Supercollider, Juce, Reaper;
- **Visual Syntesys**: Processing;
- **3D Print**: OpenSCAD;

---

## Credits
- Marco Porcella marco.porcella@mail.polimi.it
- Filippo Longhi filippo1.longhi@mail.polimi.it
- Andrea Crisafulli andrea.crisafulli@mail.polimi.it
- Giacomo De Toni giacomo1.detoni@mail.polimi.it

This project was developed as part of the Computer Music: Languages and Systems course at Politecnico di Milano (2024/2025).
 
